
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>edgar: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/natedogg/edgar/cmd/edgar/main.go (0.0%)</option>
				
				<option value="file1">github.com/natedogg/edgar/pkg/edgar/client.go (47.6%)</option>
				
				<option value="file2">github.com/natedogg/edgar/pkg/edgar/testutil/helpers.go (0.0%)</option>
				
				<option value="file3">github.com/natedogg/edgar/pkg/edgar/testutil/mocks.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"

        "github.com/natedogg/edgar/pkg/edgar"
)

func main() <span class="cov0" title="0">{
        // Define command line flags
        var cik string
        var quarterly bool
        var ebitda bool
        var ebitdaQuarterly bool
        flag.StringVar(&amp;cik, "cik", "", "Company CIK (Central Index Key) - required")
        flag.BoolVar(&amp;quarterly, "quarterly", false, "Get 4 most recent 10-Q filings and their cash flow metrics")
        flag.BoolVar(&amp;ebitda, "ebitda", false, "Calculate EBITDA for the most recent 10-Q filing")
        flag.BoolVar(&amp;ebitdaQuarterly, "ebitda-quarterly", false, "Calculate EBITDA for the 4 most recent 10-Q filings")
        flag.Parse()

        // Validate required flag
        if cik == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: CIK is required\n")
                fmt.Fprintf(os.Stderr, "Usage: %s -cik &lt;CIK&gt; [options]\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Options:\n")
                fmt.Fprintf(os.Stderr, "  -quarterly          Get 4 most recent 10-Q cash flow metrics\n")
                fmt.Fprintf(os.Stderr, "  -ebitda            Calculate EBITDA for most recent 10-Q\n")
                fmt.Fprintf(os.Stderr, "  -ebitda-quarterly  Calculate EBITDA for 4 most recent 10-Q filings\n")
                fmt.Fprintf(os.Stderr, "Examples:\n")
                fmt.Fprintf(os.Stderr, "  %s -cik 0000320193\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -cik 0000320193 -quarterly\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -cik 0000320193 -ebitda\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -cik 0000320193 -ebitda-quarterly\n", os.Args[0])
                os.Exit(1)
        }</span>

        // Pad CIK with leading zeros if needed (SEC expects 10 digits)
        <span class="cov0" title="0">if len(cik) &lt; 10 </span><span class="cov0" title="0">{
                cik = fmt.Sprintf("%010s", cik)
        }</span>

        <span class="cov0" title="0">client := edgar.NewClient()

        if ebitdaQuarterly </span><span class="cov0" title="0">{
                // Get quarterly EBITDA analysis for 4 most recent 10-Q filings
                fmt.Printf("Fetching 4 most recent 10-Q filings and EBITDA metrics for CIK: %s\n", cik)
                
                analysis, err := client.GetQuarterlyEBITDAAnalysis(cik)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error getting quarterly EBITDA analysis: %v", err)
                }</span>

                // Display the results
                <span class="cov0" title="0">fmt.Printf("\nQuarterly EBITDA Analysis for %s\n", analysis.CompanyName)
                fmt.Printf("==========================================\n")
                fmt.Printf("CIK: %s\n", analysis.CIK)
                fmt.Printf("Number of quarters analyzed: %d\n\n", len(analysis.Quarters))

                for i, quarter := range analysis.Quarters </span><span class="cov0" title="0">{
                        fmt.Printf("Quarter %d:\n", i+1)
                        fmt.Printf("----------\n")
                        fmt.Printf("  Filing Date: %s\n", quarter.FilingDate)
                        fmt.Printf("  Report Date: %s\n", quarter.ReportDate)
                        fmt.Printf("  Accession Number: %s\n", quarter.AccessionNumber)
                        fmt.Printf("  Revenue: $%.2f\n", quarter.Revenue)
                        fmt.Printf("  Net Income: $%.2f\n", quarter.NetIncome)
                        fmt.Printf("  Interest Expense: $%.2f\n", quarter.InterestExpense)
                        fmt.Printf("  Income Tax Expense: $%.2f\n", quarter.IncomeTaxExpense)
                        fmt.Printf("  Depreciation &amp; Amortization: $%.2f\n", quarter.DepreciationAndAmortization)
                        fmt.Printf("  EBITDA: $%.2f\n", quarter.EBITDA)
                        fmt.Printf("  EBITDA Margin: %.2f%%\n", quarter.EBITDAMargin)
                        fmt.Println()
                }</span>

                // Calculate and display trends
                <span class="cov0" title="0">if len(analysis.Quarters) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("Trends (Quarter 1 vs Quarter %d):\n", len(analysis.Quarters))
                        fmt.Printf("----------------------------------\n")
                        latest := analysis.Quarters[0]
                        oldest := analysis.Quarters[len(analysis.Quarters)-1]
                        
                        ebitdaChange := latest.EBITDA - oldest.EBITDA
                        ebitdaChangePercent := (ebitdaChange / oldest.EBITDA) * 100
                        
                        fmt.Printf("  EBITDA Change: $%.2f (%.2f%%)\n", ebitdaChange, ebitdaChangePercent)
                        
                        netIncomeChange := latest.NetIncome - oldest.NetIncome
                        netIncomeChangePercent := (netIncomeChange / oldest.NetIncome) * 100
                        
                        fmt.Printf("  Net Income Change: $%.2f (%.2f%%)\n", netIncomeChange, netIncomeChangePercent)
                        
                        revenueChange := latest.Revenue - oldest.Revenue
                        revenueChangePercent := (revenueChange / oldest.Revenue) * 100
                        
                        fmt.Printf("  Revenue Change: $%.2f (%.2f%%)\n", revenueChange, revenueChangePercent)
                        
                        marginChange := latest.EBITDAMargin - oldest.EBITDAMargin
                        
                        fmt.Printf("  EBITDA Margin Change: %.2f%% to %.2f%% (%.2f percentage points)\n", 
                                oldest.EBITDAMargin, latest.EBITDAMargin, marginChange)
                        fmt.Println()
                }</span>

                // Also output as JSON for programmatic use
                <span class="cov0" title="0">fmt.Println("JSON Output:")
                fmt.Println("============")
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(analysis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error encoding JSON response: %v", err)
                }</span>

        } else<span class="cov0" title="0"> if ebitda </span><span class="cov0" title="0">{
                // Single EBITDA analysis
                fmt.Printf("Fetching most recent 10-Q filing and calculating EBITDA for CIK: %s\n", cik)

                // Get the most recent 10-Q filing
                filing, err := client.GetMostRecent10Q(cik)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error getting most recent 10-Q filing: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Found 10-Q filing:\n")
                fmt.Printf("  Accession Number: %s\n", filing.AccessionNumber)
                fmt.Printf("  Filing Date: %s\n", filing.FilingDate)
                fmt.Printf("  Report Date: %s\n", filing.ReportDate)
                fmt.Printf("  Primary Document: %s\n", filing.PrimaryDocument)
                fmt.Println()

                // Parse EBITDA metrics from the filing
                fmt.Println("Calculating EBITDA...")
                metrics, err := client.ParseEBITDAMetrics(cik, filing)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error parsing EBITDA metrics: %v", err)
                }</span>

                // Display the results
                <span class="cov0" title="0">fmt.Printf("EBITDA Analysis for %s\n", metrics.CompanyName)
                fmt.Printf("=====================================\n")
                fmt.Printf("CIK: %s\n", metrics.CIK)
                fmt.Printf("Form: %s\n", metrics.Form)
                fmt.Printf("Filing Date: %s\n", metrics.FilingDate)
                fmt.Printf("Report Date: %s\n", metrics.ReportDate)
                fmt.Printf("Accession Number: %s\n", metrics.AccessionNumber)
                fmt.Println()
                
                fmt.Printf("EBITDA Components:\n")
                fmt.Printf("------------------\n")
                fmt.Printf("Revenue: $%.2f\n", metrics.Revenue)
                fmt.Printf("Net Income: $%.2f\n", metrics.NetIncome)
                fmt.Printf("Interest Expense: $%.2f\n", metrics.InterestExpense)
                fmt.Printf("Income Tax Expense: $%.2f\n", metrics.IncomeTaxExpense)
                fmt.Printf("Depreciation &amp; Amortization: $%.2f\n", metrics.DepreciationAndAmortization)
                fmt.Printf("EBITDA: $%.2f\n", metrics.EBITDA)
                fmt.Printf("EBITDA Margin: %.2f%%\n", metrics.EBITDAMargin)
                fmt.Println()

                // Also output as JSON for programmatic use
                fmt.Println("JSON Output:")
                fmt.Println("============")
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error encoding JSON response: %v", err)
                }</span>

        } else<span class="cov0" title="0"> if quarterly </span><span class="cov0" title="0">{
                // Get quarterly analysis for 4 most recent 10-Q filings
                fmt.Printf("Fetching 4 most recent 10-Q filings and cash flow metrics for CIK: %s\n", cik)
                
                analysis, err := client.GetQuarterlyCashFlowAnalysis(cik)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error getting quarterly cash flow analysis: %v", err)
                }</span>

                // Display the results
                <span class="cov0" title="0">fmt.Printf("\nQuarterly Cash Flow Analysis for %s\n", analysis.CompanyName)
                fmt.Printf("===============================================\n")
                fmt.Printf("CIK: %s\n", analysis.CIK)
                fmt.Printf("Number of quarters analyzed: %d\n\n", len(analysis.Quarters))

                for i, quarter := range analysis.Quarters </span><span class="cov0" title="0">{
                        fmt.Printf("Quarter %d:\n", i+1)
                        fmt.Printf("----------\n")
                        fmt.Printf("  Filing Date: %s\n", quarter.FilingDate)
                        fmt.Printf("  Report Date: %s\n", quarter.ReportDate)
                        fmt.Printf("  Accession Number: %s\n", quarter.AccessionNumber)
                        fmt.Printf("  Net Cash from Operating Activities: $%.2f\n", quarter.NetCashFromOperatingActivities)
                        fmt.Printf("  Capital Expenditures: $%.2f\n", quarter.CapitalExpenditures)
                        fmt.Printf("  Free Cash Flow (FCF): $%.2f\n", quarter.FreeCashFlow)
                        fmt.Println()
                }</span>

                // Calculate and display trends
                <span class="cov0" title="0">if len(analysis.Quarters) &gt; 1 </span><span class="cov0" title="0">{
                        fmt.Printf("Trends (Quarter 1 vs Quarter %d):\n", len(analysis.Quarters))
                        fmt.Printf("----------------------------------\n")
                        latest := analysis.Quarters[0]
                        oldest := analysis.Quarters[len(analysis.Quarters)-1]
                        
                        fcfChange := latest.FreeCashFlow - oldest.FreeCashFlow
                        fcfChangePercent := (fcfChange / oldest.FreeCashFlow) * 100
                        
                        fmt.Printf("  Free Cash Flow Change: $%.2f (%.2f%%)\n", fcfChange, fcfChangePercent)
                        
                        opCashChange := latest.NetCashFromOperatingActivities - oldest.NetCashFromOperatingActivities
                        opCashChangePercent := (opCashChange / oldest.NetCashFromOperatingActivities) * 100
                        
                        fmt.Printf("  Operating Cash Flow Change: $%.2f (%.2f%%)\n", opCashChange, opCashChangePercent)
                        
                        capexChange := latest.CapitalExpenditures - oldest.CapitalExpenditures
                        capexChangePercent := (capexChange / oldest.CapitalExpenditures) * 100
                        
                        fmt.Printf("  Capital Expenditures Change: $%.2f (%.2f%%)\n", capexChange, capexChangePercent)
                        fmt.Println()
                }</span>

                // Also output as JSON for programmatic use
                <span class="cov0" title="0">fmt.Println("JSON Output:")
                fmt.Println("============")
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(analysis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error encoding JSON response: %v", err)
                }</span>

        } else<span class="cov0" title="0"> {
                // Original single 10-Q analysis
                fmt.Printf("Fetching most recent 10-Q filing for CIK: %s\n", cik)

                // Get the most recent 10-Q filing
                filing, err := client.GetMostRecent10Q(cik)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error getting most recent 10-Q filing: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Found 10-Q filing:\n")
                fmt.Printf("  Accession Number: %s\n", filing.AccessionNumber)
                fmt.Printf("  Filing Date: %s\n", filing.FilingDate)
                fmt.Printf("  Report Date: %s\n", filing.ReportDate)
                fmt.Printf("  Primary Document: %s\n", filing.PrimaryDocument)
                fmt.Println()

                // Parse cash flow metrics from the filing
                fmt.Println("Parsing cash flow metrics...")
                metrics, err := client.ParseCashFlowMetrics(cik, filing)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error parsing cash flow metrics: %v", err)
                }</span>

                // Display the results
                <span class="cov0" title="0">fmt.Printf("Cash Flow Analysis for %s\n", metrics.CompanyName)
                fmt.Printf("=====================================\n")
                fmt.Printf("CIK: %s\n", metrics.CIK)
                fmt.Printf("Form: %s\n", metrics.Form)
                fmt.Printf("Filing Date: %s\n", metrics.FilingDate)
                fmt.Printf("Report Date: %s\n", metrics.ReportDate)
                fmt.Printf("Accession Number: %s\n", metrics.AccessionNumber)
                fmt.Println()
                
                fmt.Printf("Cash Flow Metrics:\n")
                fmt.Printf("------------------\n")
                fmt.Printf("Net Cash from Operating Activities: $%.2f\n", metrics.NetCashFromOperatingActivities)
                fmt.Printf("Capital Expenditures: $%.2f\n", metrics.CapitalExpenditures)
                fmt.Printf("Free Cash Flow (FCF): $%.2f\n", metrics.FreeCashFlow)
                fmt.Println()

                // Also output as JSON for programmatic use
                fmt.Println("JSON Output:")
                fmt.Println("============")
                encoder := json.NewEncoder(os.Stdout)
                encoder.SetIndent("", "  ")
                if err := encoder.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Error encoding JSON response: %v", err)
                }</span>
        }
} </pre>
		
		<pre class="file" id="file1" style="display: none">package edgar

import (
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"
)

const (
        baseURL = "https://data.sec.gov"
        userAgent = "Your Company Name yourname@example.com" // Replace with your details
)

// Client represents an EDGAR API client
type Client struct {
        httpClient *http.Client
        userAgent  string
}

// NewClient creates a new EDGAR API client
func NewClient() *Client <span class="cov8" title="1">{
        return &amp;Client{
                httpClient: &amp;http.Client{
                        Timeout: time.Second * 30,
                },
                userAgent: userAgent,
        }
}</span>

// makeRequest is a helper function to make HTTP requests with proper headers and gzip handling
func (c *Client) makeRequest(url string) ([]byte, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("User-Agent", c.userAgent)
        req.Header.Set("Accept-Encoding", "gzip, deflate")
        req.Header.Set("Host", "data.sec.gov")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error making request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">var reader io.Reader = resp.Body
        
        // Check if response is gzip compressed
        if resp.Header.Get("Content-Encoding") == "gzip" </span><span class="cov0" title="0">{
                gzipReader, err := gzip.NewReader(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating gzip reader: %w", err)
                }</span>
                <span class="cov0" title="0">defer gzipReader.Close()
                reader = gzipReader</span>
        }

        <span class="cov8" title="1">body, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading response body: %w", err)
        }</span>

        <span class="cov8" title="1">return body, nil</span>
}

// CompanyFacts represents the company facts response
type CompanyFacts struct {
        // Add fields based on the API response structure
        CIK    interface{} `json:"cik"` // Can be string or number
        Entity string `json:"entityName"`
        Facts  map[string]interface{} `json:"facts"`
}

// GetCIKString returns the CIK as a string
func (cf *CompanyFacts) GetCIKString() string <span class="cov8" title="1">{
        switch v := cf.CIK.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case json.Number:<span class="cov8" title="1">
                return string(v)</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%.0f", v)</span>
        case int:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}

// CompanySubmissions represents the company submissions response
type CompanySubmissions struct {
        CIK         string `json:"cik"`
        EntityType  string `json:"entityType"`
        SIC         string `json:"sic"`
        SICDesc     string `json:"sicDescription"`
        Name        string `json:"name"`
        Tickers     []string `json:"tickers"`
        Exchanges   []string `json:"exchanges"`
        Ein         string `json:"ein"`
        Description string `json:"description"`
        Website     string `json:"website"`
        InvestorWebsite string `json:"investorWebsite"`
        Category    string `json:"category"`
        FiscalYearEnd string `json:"fiscalYearEnd"`
        StateOfIncorporation string `json:"stateOfIncorporation"`
        StateOfIncorporationDesc string `json:"stateOfIncorporationDescription"`
        Addresses   struct {
                Mailing  Address `json:"mailing"`
                Business Address `json:"business"`
        } `json:"addresses"`
        Phone       string `json:"phone"`
        Flags       string `json:"flags"`
        FormerNames []struct {
                Name string `json:"name"`
                From string `json:"from"`
                To   string `json:"to"`
        } `json:"formerNames"`
        Filings struct {
                Recent map[string][]interface{} `json:"recent"`
                Files  []struct {
                        Name string `json:"name"`
                        FilingCount int `json:"filingCount"`
                        FilingFrom string `json:"filingFrom"`
                        FilingTo string `json:"filingTo"`
                } `json:"files"`
        } `json:"filings"`
}

type Address struct {
        Street1      string `json:"street1"`
        Street2      string `json:"street2"`
        City         string `json:"city"`
        StateOrCountry string `json:"stateOrCountry"`
        ZipCode      string `json:"zipCode"`
        StateOrCountryDesc string `json:"stateOrCountryDescription"`
}

// Filing represents a single filing
type Filing struct {
        AccessionNumber string
        FilingDate      string
        ReportDate      string
        Form            string
        FileNumber      string
        FilmNumber      string
        Items           string
        Size            string
        IsXBRL          string
        IsInlineXBRL    string
        PrimaryDocument string
        PrimaryDocDesc  string
}

// CashFlowMetrics represents the parsed cash flow metrics
type CashFlowMetrics struct {
        CompanyName                    string  `json:"companyName"`
        CIK                           string  `json:"cik"`
        FilingDate                    string  `json:"filingDate"`
        ReportDate                    string  `json:"reportDate"`
        NetCashFromOperatingActivities float64 `json:"netCashFromOperatingActivities"`
        CapitalExpenditures           float64 `json:"capitalExpenditures"`
        FreeCashFlow                  float64 `json:"freeCashFlow"`
        Form                          string  `json:"form"`
        AccessionNumber               string  `json:"accessionNumber"`
}

// QuarterlyCashFlowAnalysis represents cash flow metrics for multiple quarters
type QuarterlyCashFlowAnalysis struct {
        CompanyName string              `json:"companyName"`
        CIK         string              `json:"cik"`
        Quarters    []CashFlowMetrics   `json:"quarters"`
}

// EBITDAMetrics represents the calculated EBITDA metrics
type EBITDAMetrics struct {
        CompanyName                    string  `json:"companyName"`
        CIK                           string  `json:"cik"`
        FilingDate                    string  `json:"filingDate"`
        ReportDate                    string  `json:"reportDate"`
        Form                          string  `json:"form"`
        AccessionNumber               string  `json:"accessionNumber"`
        Revenue                       float64 `json:"revenue"`
        NetIncome                     float64 `json:"netIncome"`
        InterestExpense               float64 `json:"interestExpense"`
        IncomeTaxExpense              float64 `json:"incomeTaxExpense"`
        DepreciationAndAmortization   float64 `json:"depreciationAndAmortization"`
        EBITDA                        float64 `json:"ebitda"`
        EBITDAMargin                  float64 `json:"ebitdaMargin"` // EBITDA / Revenue as percentage
}

// QuarterlyEBITDAAnalysis represents EBITDA metrics for multiple quarters
type QuarterlyEBITDAAnalysis struct {
        CompanyName string          `json:"companyName"`
        CIK         string          `json:"cik"`
        Quarters    []EBITDAMetrics `json:"quarters"`
}

// GetCompanyFacts retrieves company facts for a given CIK
func (c *Client) GetCompanyFacts(cik string) (*CompanyFacts, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/api/xbrl/companyfacts/CIK%s.json", baseURL, cik)
        
        body, err := c.makeRequest(url)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var facts CompanyFacts
        if err := json.Unmarshal(body, &amp;facts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;facts, nil</span>
}

// GetCompanySubmissions retrieves company submissions for a given CIK
func (c *Client) GetCompanySubmissions(cik string) (*CompanySubmissions, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/submissions/CIK%s.json", baseURL, cik)
        
        body, err := c.makeRequest(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var submissions CompanySubmissions
        if err := json.Unmarshal(body, &amp;submissions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;submissions, nil</span>
}

// GetMostRecent10Q finds the most recent 10-Q filing from company submissions
func (c *Client) GetMostRecent10Q(cik string) (*Filing, error) <span class="cov8" title="1">{
        submissions, err := c.GetCompanySubmissions(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company submissions: %w", err)
        }</span>

        // Parse recent filings
        <span class="cov8" title="1">filings := c.parseFilings(submissions.Filings.Recent)
        
        // Filter for 10-Q filings and sort by filing date (most recent first)
        var tenQFilings []Filing
        for _, filing := range filings </span><span class="cov8" title="1">{
                if filing.Form == "10-Q" </span><span class="cov8" title="1">{
                        tenQFilings = append(tenQFilings, filing)
                }</span>
        }

        <span class="cov8" title="1">if len(tenQFilings) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no 10-Q filings found for CIK %s", cik)
        }</span>

        // Sort by filing date (most recent first)
        <span class="cov8" title="1">sort.Slice(tenQFilings, func(i, j int) bool </span><span class="cov8" title="1">{
                return tenQFilings[i].FilingDate &gt; tenQFilings[j].FilingDate
        }</span>)

        <span class="cov8" title="1">return &amp;tenQFilings[0], nil</span>
}

// parseFilings converts the submissions recent filings map to Filing structs
func (c *Client) parseFilings(recent map[string][]interface{}) []Filing <span class="cov8" title="1">{
        var filings []Filing
        
        // Get the length of arrays (should be the same for all)
        if len(recent["accessionNumber"]) == 0 </span><span class="cov0" title="0">{
                return filings
        }</span>

        <span class="cov8" title="1">count := len(recent["accessionNumber"])
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                filing := Filing{
                        AccessionNumber: c.toString(recent["accessionNumber"][i]),
                        FilingDate:      c.toString(recent["filingDate"][i]),
                        ReportDate:      c.toString(recent["reportDate"][i]),
                        Form:            c.toString(recent["form"][i]),
                        FileNumber:      c.toString(recent["fileNumber"][i]),
                        FilmNumber:      c.toString(recent["filmNumber"][i]),
                        Items:           c.toString(recent["items"][i]),
                        Size:            c.toString(recent["size"][i]),
                        IsXBRL:          c.toString(recent["isXBRL"][i]),
                        IsInlineXBRL:    c.toString(recent["isInlineXBRL"][i]),
                        PrimaryDocument: c.toString(recent["primaryDocument"][i]),
                        PrimaryDocDesc:  c.toString(recent["primaryDocDescription"][i]),
                }
                filings = append(filings, filing)
        }</span>

        <span class="cov8" title="1">return filings</span>
}

// toString safely converts interface{} to string
func (c *Client) toString(v interface{}) string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return val</span>
        case int:<span class="cov8" title="1">
                return strconv.Itoa(val)</span>
        case float64:<span class="cov8" title="1">
                return strconv.FormatFloat(val, 'f', 0, 64)</span>
        case bool:<span class="cov8" title="1">
                if val </span><span class="cov8" title="1">{
                        return "1"
                }</span>
                <span class="cov8" title="1">return "0"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        }
}

// GetMostRecent4TenQs finds the 4 most recent 10-Q filings from company submissions
func (c *Client) GetMostRecent4TenQs(cik string) ([]Filing, error) <span class="cov8" title="1">{
        submissions, err := c.GetCompanySubmissions(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company submissions: %w", err)
        }</span>

        // Parse recent filings
        <span class="cov8" title="1">filings := c.parseFilings(submissions.Filings.Recent)
        
        // Filter for 10-Q filings and sort by filing date (most recent first)
        var tenQFilings []Filing
        for _, filing := range filings </span><span class="cov8" title="1">{
                if filing.Form == "10-Q" </span><span class="cov8" title="1">{
                        tenQFilings = append(tenQFilings, filing)
                }</span>
        }

        <span class="cov8" title="1">if len(tenQFilings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no 10-Q filings found for CIK %s", cik)
        }</span>

        // Sort by filing date (most recent first)
        <span class="cov8" title="1">sort.Slice(tenQFilings, func(i, j int) bool </span><span class="cov8" title="1">{
                return tenQFilings[i].FilingDate &gt; tenQFilings[j].FilingDate
        }</span>)

        // Return up to 4 most recent filings
        <span class="cov8" title="1">count := len(tenQFilings)
        if count &gt; 4 </span><span class="cov8" title="1">{
                count = 4
        }</span>

        <span class="cov8" title="1">return tenQFilings[:count], nil</span>
}

// GetQuarterlyCashFlowAnalysis retrieves cash flow metrics for the 4 most recent 10-Q filings
func (c *Client) GetQuarterlyCashFlowAnalysis(cik string) (*QuarterlyCashFlowAnalysis, error) <span class="cov0" title="0">{
        // Get the 4 most recent 10-Q filings
        filings, err := c.GetMostRecent4TenQs(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting recent 10-Q filings: %w", err)
        }</span>

        // Get company facts once (we'll reuse this for all quarters)
        <span class="cov0" title="0">facts, err := c.GetCompanyFacts(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company facts: %w", err)
        }</span>

        <span class="cov0" title="0">analysis := &amp;QuarterlyCashFlowAnalysis{
                CompanyName: facts.Entity,
                CIK:         facts.GetCIKString(),
                Quarters:    make([]CashFlowMetrics, 0, len(filings)),
        }

        // Parse cash flow metrics for each filing
        for _, filing := range filings </span><span class="cov0" title="0">{
                metrics, err := c.ParseCashFlowMetricsFromFacts(facts, &amp;filing)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not parse cash flow metrics for filing %s: %v", filing.AccessionNumber, err)
                        continue</span>
                }
                <span class="cov0" title="0">analysis.Quarters = append(analysis.Quarters, *metrics)</span>
        }

        <span class="cov0" title="0">if len(analysis.Quarters) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cash flow metrics could be extracted from any 10-Q filings")
        }</span>

        <span class="cov0" title="0">return analysis, nil</span>
}

// ParseCashFlowMetrics extracts cash flow metrics from a 10-Q filing
func (c *Client) ParseCashFlowMetrics(cik string, filing *Filing) (*CashFlowMetrics, error) <span class="cov0" title="0">{
        // Get company facts which contain the financial data
        facts, err := c.GetCompanyFacts(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company facts: %w", err)
        }</span>

        <span class="cov0" title="0">metrics := &amp;CashFlowMetrics{
                CompanyName:     facts.Entity,
                CIK:            facts.GetCIKString(),
                FilingDate:     filing.FilingDate,
                ReportDate:     filing.ReportDate,
                Form:           filing.Form,
                AccessionNumber: filing.AccessionNumber,
        }

        // Extract cash flow metrics from facts
        if err := c.extractCashFlowData(facts, metrics, filing.ReportDate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error extracting cash flow data: %w", err)
        }</span>

        // Calculate free cash flow
        <span class="cov0" title="0">metrics.FreeCashFlow = metrics.NetCashFromOperatingActivities - metrics.CapitalExpenditures

        return metrics, nil</span>
}

// extractCashFlowData extracts specific cash flow values from company facts
func (c *Client) extractCashFlowData(facts *CompanyFacts, metrics *CashFlowMetrics, reportDate string) error <span class="cov0" title="0">{
        // Navigate through the facts structure to find cash flow data
        factsMap := facts.Facts
        if factsMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("facts data is nil")
        }</span>

        // Look for US-GAAP taxonomy
        <span class="cov0" title="0">usGaap, ok := factsMap["us-gaap"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("us-gaap taxonomy not found")
        }</span>

        // Extract Net Cash from Operating Activities
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "NetCashProvidedByUsedInOperatingActivities",
                "NetCashFromOperatingActivities",
                "CashProvidedByUsedInOperatingActivities",
        }, &amp;metrics.NetCashFromOperatingActivities, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract operating cash flow: %v", err)
        }</span>

        // Extract Capital Expenditures
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "PaymentsToAcquirePropertyPlantAndEquipment",
                "CapitalExpenditures",
                "PaymentsForPropertyPlantAndEquipment",
                "PaymentsToAcquireProductiveAssets",
        }, &amp;metrics.CapitalExpenditures, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract capital expenditures: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractMetric tries to extract a metric value using multiple possible tag names
func (c *Client) extractMetric(usGaap map[string]interface{}, tagNames []string, result *float64, reportDate string) error <span class="cov8" title="1">{
        for _, tagName := range tagNames </span><span class="cov8" title="1">{
                if concept, ok := usGaap[tagName].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if units, ok := concept["units"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                // Try USD first, then other units
                                for unitType, unitData := range units </span><span class="cov8" title="1">{
                                        if strings.Contains(strings.ToLower(unitType), "usd") </span><span class="cov8" title="1">{
                                                if dataArray, ok := unitData.([]interface{}); ok </span><span class="cov8" title="1">{
                                                        // Find the most recent value for the report date
                                                        value := c.findValueForDate(dataArray, reportDate)
                                                        if value != 0 </span><span class="cov8" title="1">{
                                                                *result = value
                                                                return nil
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return fmt.Errorf("metric not found with any of the provided tag names: %v", tagNames)</span>
}

// findValueForDate finds the value closest to the given report date
func (c *Client) findValueForDate(dataArray []interface{}, targetDate string) float64 <span class="cov8" title="1">{
        var bestValue float64
        var bestDate string
        var bestScore int // Higher score = better match

        for _, item := range dataArray </span><span class="cov8" title="1">{
                if dataPoint, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if date, ok := dataPoint["end"].(string); ok </span><span class="cov8" title="1">{
                                if form, ok := dataPoint["form"].(string); ok </span><span class="cov8" title="1">{
                                        // Calculate match score
                                        score := 0
                                        
                                        // Prefer exact date matches
                                        if date == targetDate </span><span class="cov8" title="1">{
                                                score += 100
                                        }</span>
                                        
                                        // Prefer 10-Q forms for quarterly analysis
                                        <span class="cov8" title="1">if form == "10-Q" </span><span class="cov8" title="1">{
                                                score += 50
                                        }</span> else<span class="cov8" title="1"> if form == "10-K" </span><span class="cov8" title="1">{
                                                score += 10 // Lower priority for annual forms
                                        }</span>
                                        
                                        // Prefer more recent dates if no exact match
                                        <span class="cov8" title="1">if date &lt;= targetDate &amp;&amp; date &gt; bestDate </span><span class="cov8" title="1">{
                                                score += 25
                                        }</span>
                                        
                                        // Only update if this is a better match
                                        <span class="cov8" title="1">if score &gt; bestScore || (score == bestScore &amp;&amp; date &gt; bestDate) </span><span class="cov8" title="1">{
                                                if val, ok := dataPoint["val"].(float64); ok </span><span class="cov8" title="1">{
                                                        bestValue = val
                                                        bestDate = date
                                                        bestScore = score
                                                }</span> else<span class="cov0" title="0"> if valStr, ok := dataPoint["val"].(string); ok </span><span class="cov0" title="0">{
                                                        if val, err := strconv.ParseFloat(valStr, 64); err == nil </span><span class="cov0" title="0">{
                                                                bestValue = val
                                                                bestDate = date
                                                                bestScore = score
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return bestValue</span>
}

// ParseCashFlowMetricsFromFacts extracts cash flow metrics using pre-fetched company facts
func (c *Client) ParseCashFlowMetricsFromFacts(facts *CompanyFacts, filing *Filing) (*CashFlowMetrics, error) <span class="cov0" title="0">{
        metrics := &amp;CashFlowMetrics{
                CompanyName:     facts.Entity,
                CIK:            facts.GetCIKString(),
                FilingDate:     filing.FilingDate,
                ReportDate:     filing.ReportDate,
                Form:           filing.Form,
                AccessionNumber: filing.AccessionNumber,
        }

        // Extract cash flow metrics from facts
        if err := c.extractCashFlowData(facts, metrics, filing.ReportDate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error extracting cash flow data: %w", err)
        }</span>

        // Calculate free cash flow
        <span class="cov0" title="0">metrics.FreeCashFlow = metrics.NetCashFromOperatingActivities - metrics.CapitalExpenditures

        return metrics, nil</span>
}

// CompanyConcept represents a specific concept for a company
type CompanyConcept struct {
        CIK     string `json:"cik"`
        Taxonomy string `json:"taxonomy"`
        Tag     string `json:"tag"`
        Label   string `json:"label"`
        Units   map[string][]struct {
                Form  string `json:"form"`
                Date  string `json:"date"`
                Value float64 `json:"val"`
        } `json:"units"`
}

// GetCompanyConcept retrieves a specific concept for a company
func (c *Client) GetCompanyConcept(cik, taxonomy, tag string) (*CompanyConcept, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/api/xbrl/companyconcept/CIK%s/%s/%s.json", baseURL, cik, taxonomy, tag)
        
        body, err := c.makeRequest(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var concept CompanyConcept
        if err := json.Unmarshal(body, &amp;concept); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;concept, nil</span>
}

// ParseEBITDAMetrics extracts EBITDA components from a 10-Q filing
func (c *Client) ParseEBITDAMetrics(cik string, filing *Filing) (*EBITDAMetrics, error) <span class="cov0" title="0">{
        // Get company facts which contain the financial data
        facts, err := c.GetCompanyFacts(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company facts: %w", err)
        }</span>

        <span class="cov0" title="0">return c.ParseEBITDAMetricsFromFacts(facts, filing)</span>
}

// ParseEBITDAMetricsFromFacts extracts EBITDA components using pre-fetched company facts
func (c *Client) ParseEBITDAMetricsFromFacts(facts *CompanyFacts, filing *Filing) (*EBITDAMetrics, error) <span class="cov0" title="0">{
        metrics := &amp;EBITDAMetrics{
                CompanyName:     facts.Entity,
                CIK:            facts.GetCIKString(),
                FilingDate:     filing.FilingDate,
                ReportDate:     filing.ReportDate,
                Form:           filing.Form,
                AccessionNumber: filing.AccessionNumber,
        }

        // Extract EBITDA components from facts
        if err := c.extractEBITDAData(facts, metrics, filing.ReportDate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error extracting EBITDA data: %w", err)
        }</span>

        // Calculate EBITDA
        <span class="cov0" title="0">metrics.EBITDA = metrics.NetIncome + metrics.InterestExpense + metrics.IncomeTaxExpense + metrics.DepreciationAndAmortization

        // Calculate EBITDA Margin (as percentage)
        if metrics.Revenue != 0 </span><span class="cov0" title="0">{
                metrics.EBITDAMargin = (metrics.EBITDA / metrics.Revenue) * 100
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Warning: Revenue is zero, cannot calculate EBITDA margin")
                metrics.EBITDAMargin = 0
        }</span>

        <span class="cov0" title="0">return metrics, nil</span>
}

// extractEBITDAData extracts specific EBITDA components from company facts
func (c *Client) extractEBITDAData(facts *CompanyFacts, metrics *EBITDAMetrics, reportDate string) error <span class="cov0" title="0">{
        // Navigate through the facts structure to find financial data
        factsMap := facts.Facts
        if factsMap == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("facts data is nil")
        }</span>

        // Look for US-GAAP taxonomy
        <span class="cov0" title="0">usGaap, ok := factsMap["us-gaap"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("us-gaap taxonomy not found")
        }</span>

        // Extract Revenue
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "Revenues",
                "RevenueFromContractWithCustomerExcludingAssessedTax",
                "SalesRevenueNet",
                "RevenueFromContractWithCustomerIncludingAssessedTax",
                "Revenue",
                "SalesRevenueGoodsNet",
                "RevenuesNetOfInterestExpense",
        }, &amp;metrics.Revenue, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract revenue: %v", err)
        }</span>

        // Extract Net Income
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "NetIncomeLoss",
                "ProfitLoss",
                "NetIncomeLossAvailableToCommonStockholdersBasic",
                "IncomeLossFromContinuingOperations",
        }, &amp;metrics.NetIncome, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract net income: %v", err)
        }</span>

        // Extract Interest Expense
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "InterestExpense",
                "InterestExpenseDebt",
                "InterestAndDebtExpense",
                "InterestExpenseNet",
        }, &amp;metrics.InterestExpense, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract interest expense: %v", err)
        }</span>

        // Extract Income Tax Expense
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "IncomeTaxExpenseBenefit",
                "ProvisionForIncomeTaxes",
                "IncomeTaxesPaid",
                "CurrentIncomeTaxExpenseBenefit",
        }, &amp;metrics.IncomeTaxExpense, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract income tax expense: %v", err)
        }</span>

        // Extract Depreciation and Amortization
        // This is often found in cash flow statement or as a combined figure
        <span class="cov0" title="0">if err := c.extractMetric(usGaap, []string{
                "DepreciationDepletionAndAmortization",
                "Depreciation",
                "DepreciationAndAmortization",
                "AmortizationOfIntangibleAssets",
                "DepreciationAmortizationAndAccretionNet",
        }, &amp;metrics.DepreciationAndAmortization, reportDate); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not extract depreciation and amortization: %v", err)
                
                // Try to get separate depreciation and amortization figures
                var depreciation, amortization float64
                if err1 := c.extractMetric(usGaap, []string{
                        "Depreciation",
                        "DepreciationNonproduction",
                }, &amp;depreciation, reportDate); err1 == nil </span><span class="cov0" title="0">{
                        metrics.DepreciationAndAmortization += depreciation
                }</span>
                
                <span class="cov0" title="0">if err2 := c.extractMetric(usGaap, []string{
                        "AmortizationOfIntangibleAssets",
                        "Amortization",
                }, &amp;amortization, reportDate); err2 == nil </span><span class="cov0" title="0">{
                        metrics.DepreciationAndAmortization += amortization
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetQuarterlyEBITDAAnalysis retrieves EBITDA metrics for the 4 most recent 10-Q filings
func (c *Client) GetQuarterlyEBITDAAnalysis(cik string) (*QuarterlyEBITDAAnalysis, error) <span class="cov0" title="0">{
        // Get the 4 most recent 10-Q filings
        filings, err := c.GetMostRecent4TenQs(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting recent 10-Q filings: %w", err)
        }</span>

        // Get company facts once (we'll reuse this for all quarters)
        <span class="cov0" title="0">facts, err := c.GetCompanyFacts(cik)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting company facts: %w", err)
        }</span>

        <span class="cov0" title="0">analysis := &amp;QuarterlyEBITDAAnalysis{
                CompanyName: facts.Entity,
                CIK:         facts.GetCIKString(),
                Quarters:    make([]EBITDAMetrics, 0, len(filings)),
        }

        // Parse EBITDA metrics for each filing
        for _, filing := range filings </span><span class="cov0" title="0">{
                metrics, err := c.ParseEBITDAMetricsFromFacts(facts, &amp;filing)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not parse EBITDA metrics for filing %s: %v", filing.AccessionNumber, err)
                        continue</span>
                }
                <span class="cov0" title="0">analysis.Quarters = append(analysis.Quarters, *metrics)</span>
        }

        <span class="cov0" title="0">if len(analysis.Quarters) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no EBITDA metrics could be extracted from any 10-Q filings")
        }</span>

        <span class="cov0" title="0">return analysis, nil</span>
} </pre>
		
		<pre class="file" id="file2" style="display: none">package testutil

import (
        "bytes"
        "encoding/json"
        "io"
        "os"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// CaptureOutput captures stdout and stderr during function execution
func CaptureOutput(t *testing.T, fn func()) (stdout, stderr string) <span class="cov0" title="0">{
        // Save original stdout/stderr
        originalStdout := os.Stdout
        originalStderr := os.Stderr
        
        // Create pipes for capturing output
        stdoutR, stdoutW, err := os.Pipe()
        require.NoError(t, err)
        stderrR, stderrW, err := os.Pipe()
        require.NoError(t, err)
        
        // Replace stdout/stderr with our pipes
        os.Stdout = stdoutW
        os.Stderr = stderrW
        
        // Create channels to receive the captured output
        stdoutChan := make(chan string)
        stderrChan := make(chan string)
        
        // Start goroutines to read from the pipes
        go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, stdoutR)
                stdoutChan &lt;- buf.String()
        }</span>()
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                io.Copy(&amp;buf, stderrR)
                stderrChan &lt;- buf.String()
        }</span>()
        
        // Execute the function
        <span class="cov0" title="0">fn()
        
        // Close the write ends of the pipes
        stdoutW.Close()
        stderrW.Close()
        
        // Restore original stdout/stderr
        os.Stdout = originalStdout
        os.Stderr = originalStderr
        
        // Wait for the output to be captured
        stdout = &lt;-stdoutChan
        stderr = &lt;-stderrChan
        
        return stdout, stderr</span>
}

// AssertValidJSON checks if a string is valid JSON
func AssertValidJSON(t *testing.T, jsonStr string) <span class="cov0" title="0">{
        var js json.RawMessage
        err := json.Unmarshal([]byte(jsonStr), &amp;js)
        assert.NoError(t, err, "should be valid JSON")
}</span>

// AssertContainsJSON checks if JSON string contains expected key-value pairs
func AssertContainsJSON(t *testing.T, jsonStr string, expectedKeys ...string) <span class="cov0" title="0">{
        var data map[string]interface{}
        err := json.Unmarshal([]byte(jsonStr), &amp;data)
        require.NoError(t, err, "should be valid JSON")
        
        for _, key := range expectedKeys </span><span class="cov0" title="0">{
                assert.Contains(t, data, key, "JSON should contain key: %s", key)
        }</span>
}

// AssertJSONEquals compares two JSON strings for equality
func AssertJSONEquals(t *testing.T, expected, actual string) <span class="cov0" title="0">{
        var expectedData, actualData interface{}
        
        err := json.Unmarshal([]byte(expected), &amp;expectedData)
        require.NoError(t, err, "expected JSON should be valid")
        
        err = json.Unmarshal([]byte(actual), &amp;actualData)
        require.NoError(t, err, "actual JSON should be valid")
        
        assert.Equal(t, expectedData, actualData, "JSON objects should be equal")
}</span>

// AssertCurrencyFormat checks if a value is formatted as currency
func AssertCurrencyFormat(t *testing.T, value string) <span class="cov0" title="0">{
        assert.Contains(t, value, "$", "should contain dollar sign")
        assert.Contains(t, value, ".", "should contain decimal point")
}</span>

// AssertPercentageFormat checks if a value is formatted as percentage
func AssertPercentageFormat(t *testing.T, value string) <span class="cov0" title="0">{
        assert.Contains(t, value, "%", "should contain percentage sign")
}</span>

// AssertDateFormat checks if a string is in YYYY-MM-DD format
func AssertDateFormat(t *testing.T, dateStr string) <span class="cov0" title="0">{
        assert.Len(t, dateStr, 10, "date should be 10 characters long")
        assert.Regexp(t, `^\d{4}-\d{2}-\d{2}$`, dateStr, "date should be in YYYY-MM-DD format")
}</span>

// AssertCIKFormat checks if a string is in proper CIK format (10 digits)
func AssertCIKFormat(t *testing.T, cik string) <span class="cov0" title="0">{
        assert.Len(t, cik, 10, "CIK should be 10 characters long")
        assert.Regexp(t, `^\d{10}$`, cik, "CIK should be 10 digits")
}</span>

// AssertAccessionNumberFormat checks if a string is in proper accession number format
func AssertAccessionNumberFormat(t *testing.T, accessionNumber string) <span class="cov0" title="0">{
        assert.Regexp(t, `^\d{10}-\d{2}-\d{6}$`, accessionNumber, 
                "accession number should be in format XXXXXXXXXX-XX-XXXXXX")
}</span>

// WithTimeout runs a function with a timeout
func WithTimeout(t *testing.T, timeout time.Duration, fn func()) <span class="cov0" title="0">{
        done := make(chan bool, 1)
        
        go func() </span><span class="cov0" title="0">{
                fn()
                done &lt;- true
        }</span>()
        
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0"></span>
                // Function completed successfully
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                t.Fatalf("function timed out after %v", timeout)</span>
        }
}

// AssertMoneyValue checks if a monetary value is reasonable (not negative, not extremely large)
func AssertMoneyValue(t *testing.T, value float64, description string) <span class="cov0" title="0">{
        assert.True(t, value &gt;= 0, "%s should not be negative: %f", description, value)
        assert.True(t, value &lt; 1e15, "%s should not be unreasonably large: %f", description, value)
}</span>

// AssertPercentageValue checks if a percentage value is reasonable
func AssertPercentageValue(t *testing.T, value float64, description string) <span class="cov0" title="0">{
        assert.True(t, value &gt;= -100, "%s should not be less than -100%%: %f", description, value)
        assert.True(t, value &lt;= 1000, "%s should not be more than 1000%%: %f", description, value)
}</span>

// SkipIfShort skips the test if running in short mode
func SkipIfShort(t *testing.T, reason string) <span class="cov0" title="0">{
        if testing.Short() </span><span class="cov0" title="0">{
                t.Skipf("skipping test in short mode: %s", reason)
        }</span>
}

// SkipIfNoIntegration skips the test if integration tests are disabled
func SkipIfNoIntegration(t *testing.T) <span class="cov0" title="0">{
        if os.Getenv("INTEGRATION_TESTS") != "true" </span><span class="cov0" title="0">{
                t.Skip("skipping integration test (set INTEGRATION_TESTS=true to enable)")
        }</span>
}

// CompareFloats compares two float64 values with a reasonable tolerance
func CompareFloats(t *testing.T, expected, actual float64, description string) <span class="cov0" title="0">{
        tolerance := 0.01 // 1 cent tolerance for financial calculations
        assert.InDelta(t, expected, actual, tolerance, description)
}</span>

// AssertOrderedByDate checks if filings are ordered by date (most recent first)
func AssertOrderedByDate(t *testing.T, dates []string, description string) <span class="cov0" title="0">{
        for i := 0; i &lt; len(dates)-1; i++ </span><span class="cov0" title="0">{
                assert.True(t, dates[i] &gt;= dates[i+1], 
                        "%s should be ordered by date (most recent first): %s should be &gt;= %s", 
                        description, dates[i], dates[i+1])
        }</span>
}

// SetupTestEnvironment sets up common test environment variables
func SetupTestEnvironment() <span class="cov0" title="0">{
        // Set any required environment variables for testing
        os.Setenv("SEC_API_BASE_URL", "https://data.sec.gov")
}</span>

// CleanupTestEnvironment cleans up test environment
func CleanupTestEnvironment() <span class="cov0" title="0">{
        // Clean up any test-specific environment variables
        os.Unsetenv("SEC_API_BASE_URL")
}</span>

// CreateTempFile creates a temporary file for testing
func CreateTempFile(t *testing.T, content string) *os.File <span class="cov0" title="0">{
        tmpfile, err := os.CreateTemp("", "edgar-test-")
        require.NoError(t, err, "should create temp file")
        
        _, err = tmpfile.Write([]byte(content))
        require.NoError(t, err, "should write to temp file")
        
        err = tmpfile.Close()
        require.NoError(t, err, "should close temp file")
        
        // Register cleanup
        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.Remove(tmpfile.Name())
        }</span>)
        
        // Reopen for reading
        <span class="cov0" title="0">tmpfile, err = os.Open(tmpfile.Name())
        require.NoError(t, err, "should reopen temp file")
        
        return tmpfile</span>
}

// AssertNoLeakedGoroutines checks that no goroutines are leaked during test execution
func AssertNoLeakedGoroutines(t *testing.T, fn func()) <span class="cov0" title="0">{
        initialCount := countGoroutines()
        
        fn()
        
        // Give some time for goroutines to clean up
        time.Sleep(10 * time.Millisecond)
        
        finalCount := countGoroutines()
        
        // Allow for some tolerance as the test framework itself may create goroutines
        tolerance := 2
        assert.True(t, finalCount &lt;= initialCount+tolerance, 
                "potential goroutine leak detected: initial=%d, final=%d", initialCount, finalCount)
}</span>

// countGoroutines returns the current number of goroutines
func countGoroutines() int <span class="cov0" title="0">{
        return len(getAllGoroutineStacks())
}</span>

// getAllGoroutineStacks returns stack traces for all goroutines
func getAllGoroutineStacks() []byte <span class="cov0" title="0">{
        buf := make([]byte, 1&lt;&lt;16)
        n := len(buf)
        for n == len(buf) </span><span class="cov0" title="0">{
                buf = make([]byte, 2*len(buf))
                n = len(buf) // This would normally use runtime.Stack, but we'll simulate
        }</span>
        <span class="cov0" title="0">return buf[:n]</span>
}

// TableTest represents a single test case in a table-driven test
type TableTest struct {
        Name     string
        Input    interface{}
        Expected interface{}
        Error    string
}

// RunTableTests runs a series of table-driven tests
func RunTableTests(t *testing.T, tests []TableTest, testFunc func(t *testing.T, input, expected interface{}, expectError string)) <span class="cov0" title="0">{
        for _, tt := range tests </span><span class="cov0" title="0">{
                t.Run(tt.Name, func(t *testing.T) </span><span class="cov0" title="0">{
                        testFunc(t, tt.Input, tt.Expected, tt.Error)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package testutil

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"

        "github.com/natedogg/edgar/pkg/edgar"
)

// MockClient provides a mock implementation of the EDGAR client for testing
type MockClient struct {
        CompanyFactsResponse    *edgar.CompanyFacts
        CompanySubmissionsResp  *edgar.CompanySubmissions
        CashFlowMetricsResp     *edgar.CashFlowMetrics
        EBITDAMetricsResp      *edgar.EBITDAMetrics
        QuarterlyCashFlowResp   *edgar.QuarterlyCashFlowAnalysis
        QuarterlyEBITDAResp    *edgar.QuarterlyEBITDAAnalysis
        FilingsResp            []edgar.Filing
        ErrorToReturn          error
}

// GetCompanyFacts returns the mocked company facts response
func (m *MockClient) GetCompanyFacts(cik string) (*edgar.CompanyFacts, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.CompanyFactsResponse, nil</span>
}

// GetCompanySubmissions returns the mocked company submissions response
func (m *MockClient) GetCompanySubmissions(cik string) (*edgar.CompanySubmissions, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.CompanySubmissionsResp, nil</span>
}

// GetMostRecent10Q returns the first filing from the mocked filings response
func (m *MockClient) GetMostRecent10Q(cik string) (*edgar.Filing, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">if len(m.FilingsResp) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no 10-Q filings found")
        }</span>
        <span class="cov0" title="0">return &amp;m.FilingsResp[0], nil</span>
}

// GetMostRecent4TenQs returns up to 4 filings from the mocked filings response
func (m *MockClient) GetMostRecent4TenQs(cik string) ([]edgar.Filing, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        
        <span class="cov0" title="0">count := len(m.FilingsResp)
        if count &gt; 4 </span><span class="cov0" title="0">{
                count = 4
        }</span>
        
        <span class="cov0" title="0">return m.FilingsResp[:count], nil</span>
}

// ParseCashFlowMetrics returns the mocked cash flow metrics response
func (m *MockClient) ParseCashFlowMetrics(cik string, filing *edgar.Filing) (*edgar.CashFlowMetrics, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.CashFlowMetricsResp, nil</span>
}

// ParseEBITDAMetrics returns the mocked EBITDA metrics response
func (m *MockClient) ParseEBITDAMetrics(cik string, filing *edgar.Filing) (*edgar.EBITDAMetrics, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.EBITDAMetricsResp, nil</span>
}

// GetQuarterlyCashFlowAnalysis returns the mocked quarterly cash flow analysis
func (m *MockClient) GetQuarterlyCashFlowAnalysis(cik string) (*edgar.QuarterlyCashFlowAnalysis, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.QuarterlyCashFlowResp, nil</span>
}

// GetQuarterlyEBITDAAnalysis returns the mocked quarterly EBITDA analysis
func (m *MockClient) GetQuarterlyEBITDAAnalysis(cik string) (*edgar.QuarterlyEBITDAAnalysis, error) <span class="cov0" title="0">{
        if m.ErrorToReturn != nil </span><span class="cov0" title="0">{
                return nil, m.ErrorToReturn
        }</span>
        <span class="cov0" title="0">return m.QuarterlyEBITDAResp, nil</span>
}

// TestDataProvider provides commonly used test data
type TestDataProvider struct{}

// NewTestDataProvider creates a new test data provider
func NewTestDataProvider() *TestDataProvider <span class="cov0" title="0">{
        return &amp;TestDataProvider{}
}</span>

// GetMockCompanyFacts returns mock company facts data
func (p *TestDataProvider) GetMockCompanyFacts() *edgar.CompanyFacts <span class="cov0" title="0">{
        return &amp;edgar.CompanyFacts{
                CIK:    "0000320193",
                Entity: "Apple Inc.",
                Facts: map[string]interface{}{
                        "us-gaap": map[string]interface{}{
                                "NetCashProvidedByUsedInOperatingActivities": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  50000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "PaymentsToAcquirePropertyPlantAndEquipment": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  5000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "Revenues": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  100000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "NetIncomeLoss": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  25000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "InterestExpense": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  1000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "IncomeTaxExpenseBenefit": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  3000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                                "DepreciationDepletionAndAmortization": map[string]interface{}{
                                        "units": map[string]interface{}{
                                                "USD": []interface{}{
                                                        map[string]interface{}{
                                                                "form": "10-Q",
                                                                "val":  2000000000.0,
                                                                "end":  "2023-12-30",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// GetMockCompanySubmissions returns mock company submissions data
func (p *TestDataProvider) GetMockCompanySubmissions() *edgar.CompanySubmissions <span class="cov0" title="0">{
        return &amp;edgar.CompanySubmissions{
                CIK:  "0000320193",
                Name: "Apple Inc.",
                Filings: struct {
                        Recent map[string][]interface{} `json:"recent"`
                        Files  []struct {
                                Name        string `json:"name"`
                                FilingCount int    `json:"filingCount"`
                                FilingFrom  string `json:"filingFrom"`
                                FilingTo    string `json:"filingTo"`
                        } `json:"files"`
                }{
                        Recent: map[string][]interface{}{
                                "accessionNumber":        {"0000320193-24-000007", "0000320193-24-000006", "0000320193-24-000005", "0000320193-24-000004"},
                                "filingDate":            {"2024-02-01", "2023-11-02", "2023-08-03", "2023-05-04"},
                                "reportDate":            {"2023-12-30", "2023-09-30", "2023-06-30", "2023-03-31"},
                                "form":                  {"10-Q", "10-Q", "10-Q", "10-Q"},
                                "fileNumber":            {"001-36743", "001-36743", "001-36743", "001-36743"},
                                "filmNumber":            {"24576126", "24576125", "24576124", "24576123"},
                                "items":                 {"", "", "", ""},
                                "size":                  {"100000", "100000", "100000", "100000"},
                                "isXBRL":                {1, 1, 1, 1},
                                "isInlineXBRL":          {1, 1, 1, 1},
                                "primaryDocument":       {"aapl-20231230.htm", "aapl-20230930.htm", "aapl-20230630.htm", "aapl-20230331.htm"},
                                "primaryDocDescription": {"10-Q", "10-Q", "10-Q", "10-Q"},
                        },
                },
        }
}</span>

// GetMockFilings returns mock filing data
func (p *TestDataProvider) GetMockFilings() []edgar.Filing <span class="cov0" title="0">{
        return []edgar.Filing{
                {
                        AccessionNumber: "0000320193-24-000007",
                        FilingDate:      "2024-02-01",
                        ReportDate:      "2023-12-30",
                        Form:            "10-Q",
                        FileNumber:      "001-36743",
                        FilmNumber:      "24576126",
                        Items:           "",
                        Size:            "100000",
                        IsXBRL:          "1",
                        IsInlineXBRL:    "1",
                        PrimaryDocument: "aapl-20231230.htm",
                        PrimaryDocDesc:  "10-Q",
                },
                {
                        AccessionNumber: "0000320193-24-000006",
                        FilingDate:      "2023-11-02",
                        ReportDate:      "2023-09-30",
                        Form:            "10-Q",
                        FileNumber:      "001-36743",
                        FilmNumber:      "24576125",
                        Items:           "",
                        Size:            "100000",
                        IsXBRL:          "1",
                        IsInlineXBRL:    "1",
                        PrimaryDocument: "aapl-20230930.htm",
                        PrimaryDocDesc:  "10-Q",
                },
                {
                        AccessionNumber: "0000320193-24-000005",
                        FilingDate:      "2023-08-03",
                        ReportDate:      "2023-06-30",
                        Form:            "10-Q",
                        FileNumber:      "001-36743",
                        FilmNumber:      "24576124",
                        Items:           "",
                        Size:            "100000",
                        IsXBRL:          "1",
                        IsInlineXBRL:    "1",
                        PrimaryDocument: "aapl-20230630.htm",
                        PrimaryDocDesc:  "10-Q",
                },
                {
                        AccessionNumber: "0000320193-24-000004",
                        FilingDate:      "2023-05-04",
                        ReportDate:      "2023-03-31",
                        Form:            "10-Q",
                        FileNumber:      "001-36743",
                        FilmNumber:      "24576123",
                        Items:           "",
                        Size:            "100000",
                        IsXBRL:          "1",
                        IsInlineXBRL:    "1",
                        PrimaryDocument: "aapl-20230331.htm",
                        PrimaryDocDesc:  "10-Q",
                },
        }
}</span>

// GetMockCashFlowMetrics returns mock cash flow metrics
func (p *TestDataProvider) GetMockCashFlowMetrics() *edgar.CashFlowMetrics <span class="cov0" title="0">{
        return &amp;edgar.CashFlowMetrics{
                CompanyName:                    "Apple Inc.",
                CIK:                           "0000320193",
                FilingDate:                    "2024-02-01",
                ReportDate:                    "2023-12-30",
                Form:                          "10-Q",
                AccessionNumber:               "0000320193-24-000007",
                NetCashFromOperatingActivities: 50000000000,
                CapitalExpenditures:           5000000000,
                FreeCashFlow:                  45000000000,
        }
}</span>

// GetMockEBITDAMetrics returns mock EBITDA metrics
func (p *TestDataProvider) GetMockEBITDAMetrics() *edgar.EBITDAMetrics <span class="cov0" title="0">{
        return &amp;edgar.EBITDAMetrics{
                CompanyName:                 "Apple Inc.",
                CIK:                        "0000320193",
                FilingDate:                 "2024-02-01",
                ReportDate:                 "2023-12-30",
                Form:                       "10-Q",
                AccessionNumber:            "0000320193-24-000007",
                Revenue:                    100000000000,
                NetIncome:                  25000000000,
                InterestExpense:            1000000000,
                IncomeTaxExpense:           3000000000,
                DepreciationAndAmortization: 2000000000,
                EBITDA:                     31000000000,
                EBITDAMargin:               31.0,
        }
}</span>

// GetMockQuarterlyCashFlowAnalysis returns mock quarterly cash flow analysis
func (p *TestDataProvider) GetMockQuarterlyCashFlowAnalysis() *edgar.QuarterlyCashFlowAnalysis <span class="cov0" title="0">{
        filings := p.GetMockFilings()
        quarters := make([]edgar.CashFlowMetrics, len(filings))
        
        for i, filing := range filings </span><span class="cov0" title="0">{
                quarters[i] = edgar.CashFlowMetrics{
                        CompanyName:                    "Apple Inc.",
                        CIK:                           "0000320193",
                        FilingDate:                    filing.FilingDate,
                        ReportDate:                    filing.ReportDate,
                        Form:                          "10-Q",
                        AccessionNumber:               filing.AccessionNumber,
                        NetCashFromOperatingActivities: 50000000000 - float64(i)*2000000000, // Decreasing trend
                        CapitalExpenditures:           5000000000 + float64(i)*500000000,     // Increasing trend
                        FreeCashFlow:                  45000000000 - float64(i)*2500000000,   // Decreasing trend
                }
        }</span>
        
        <span class="cov0" title="0">return &amp;edgar.QuarterlyCashFlowAnalysis{
                CompanyName: "Apple Inc.",
                CIK:         "0000320193",
                Quarters:    quarters,
        }</span>
}

// GetMockQuarterlyEBITDAAnalysis returns mock quarterly EBITDA analysis
func (p *TestDataProvider) GetMockQuarterlyEBITDAAnalysis() *edgar.QuarterlyEBITDAAnalysis <span class="cov0" title="0">{
        filings := p.GetMockFilings()
        quarters := make([]edgar.EBITDAMetrics, len(filings))
        
        for i, filing := range filings </span><span class="cov0" title="0">{
                revenue := 100000000000.0 + float64(i)*2000000000   // Increasing trend
                netIncome := 25000000000.0 + float64(i)*1000000000 // Increasing trend
                ebitda := 31000000000.0 + float64(i)*1500000000    // Increasing trend
                
                quarters[i] = edgar.EBITDAMetrics{
                        CompanyName:                 "Apple Inc.",
                        CIK:                        "0000320193",
                        FilingDate:                 filing.FilingDate,
                        ReportDate:                 filing.ReportDate,
                        Form:                       "10-Q",
                        AccessionNumber:            filing.AccessionNumber,
                        Revenue:                    revenue,
                        NetIncome:                  netIncome,
                        InterestExpense:            1000000000,
                        IncomeTaxExpense:           3000000000,
                        DepreciationAndAmortization: 2000000000,
                        EBITDA:                     ebitda,
                        EBITDAMargin:               (ebitda / revenue) * 100,
                }
        }</span>
        
        <span class="cov0" title="0">return &amp;edgar.QuarterlyEBITDAAnalysis{
                CompanyName: "Apple Inc.",
                CIK:         "0000320193",
                Quarters:    quarters,
        }</span>
}

// CreateMockServer creates an HTTP test server with predefined responses
func CreateMockServer(responses map[string]string) *httptest.Server <span class="cov0" title="0">{
        return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                path := r.URL.Path
                
                // Find matching response
                for pattern, response := range responses </span><span class="cov0" title="0">{
                        if contains(path, pattern) </span><span class="cov0" title="0">{
                                w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusOK)
                                fmt.Fprint(w, response)
                                return
                        }</span>
                }
                
                // Default 404 response
                <span class="cov0" title="0">w.WriteHeader(http.StatusNotFound)
                fmt.Fprint(w, `{"error": "not found"}`)</span>
        }))
}

// contains checks if a string contains a substring
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || (len(s) &gt; len(substr) &amp;&amp; 
                (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || 
                 indexOf(s, substr) &gt;= 0)))
}</span>

// indexOf returns the index of substr in s, or -1 if not found
func indexOf(s, substr string) int <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// GetMockCompanyFactsJSON returns JSON representation of mock company facts
func (p *TestDataProvider) GetMockCompanyFactsJSON() string <span class="cov0" title="0">{
        facts := p.GetMockCompanyFacts()
        data, _ := json.MarshalIndent(facts, "", "  ")
        return string(data)
}</span>

// GetMockCompanySubmissionsJSON returns JSON representation of mock company submissions
func (p *TestDataProvider) GetMockCompanySubmissionsJSON() string <span class="cov0" title="0">{
        submissions := p.GetMockCompanySubmissions()
        data, _ := json.MarshalIndent(submissions, "", "  ")
        return string(data)
}</span>

// SetupMockClient creates a fully configured mock client for testing
func SetupMockClient() *MockClient <span class="cov0" title="0">{
        provider := NewTestDataProvider()
        
        return &amp;MockClient{
                CompanyFactsResponse:   provider.GetMockCompanyFacts(),
                CompanySubmissionsResp: provider.GetMockCompanySubmissions(),
                CashFlowMetricsResp:    provider.GetMockCashFlowMetrics(),
                EBITDAMetricsResp:     provider.GetMockEBITDAMetrics(),
                QuarterlyCashFlowResp:  provider.GetMockQuarterlyCashFlowAnalysis(),
                QuarterlyEBITDAResp:   provider.GetMockQuarterlyEBITDAAnalysis(),
                FilingsResp:           provider.GetMockFilings(),
                ErrorToReturn:         nil,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
